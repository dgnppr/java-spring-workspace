# Java Annotation

## 어노테이션이란?

- 어노테이션은 주석이다. 주석처럼 프로그래밍 언어에 영향을 미치지 않고 정보를 제공할 수 있다. 즉, 작동하는(구현된) 코드가 아니라 표시를 해놓은 것이다.
- 어노테이션을 사용하여 프로그램에 필요한 설정 정보를 소스 코드안에 심을 수 있다.

```java
@Test // 이 메서드가 테스트 대상임을 테스트 프로그램에게 알린다.
void method(){

        }
```

<br>

## 어노테이션 등장 배경

- 예전에는 소스 코드에 대한 문서를 따로 관리했고, 소스 코드 변경이 발생할 때마다 관련 문서를 수정해줬어야 했다. 이러한 불편한 점 때문에 소스 코드에 대한 문서를 따로 만들기보다 소스 코드와 문서를 하나의
  파일로 관리할 수 있도록 소스 코드에 주석을 함께 작성하여 문서를 관리했다.


- 위 기능을 응용하여 **소스 코드 안에 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 어노테이션이다.** 예전에는 프로그램을 위한 정보를 소스 코드와 분리된 설정 파일(ex: `XML`)을 따로
  관리했었는데, 어노테이션을 사용함으로써 관리를 용이하게 했다.

<br>

## `java.lang.annotation.Annotation`

- 어노테이션의 조상은 `java.lang.annotation.Annotation`이다.
- 바이트 코드를 통해 확인해보면 아래와 같음을 확인할 수 있다.

```java
// class version 61.0 (61)
// access flags 0x2600
abstract @interface me/dgpr/MyAnnotation implements java/lang/annotation/Annotation{

// compiled from: AnnotationTest.java

@Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.RUNTIME)

// access flags 0x401
public abstract value()Ljava/lang/String;
default="test"
        }

```

<br>

## 어노테이션 엘리먼트 규칙

- 어노테이션 내에 선언된 메서드를 엘리먼트라고 한다.


- 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.
    - 타입으로는 `기본형`, `String`, `enum`, `annotation`, `Class` 그리고 이들의 배열을 허용한다.
    - 엘리먼트 이름 뒤에는 `()`를 붙여야 한다. `()`안에 매개변수는 선언할 수 없다.
    - 엘리먼트를 타입 매개변수로 정의할 수 없다. (ex: `ArrayList<T> list();`)
    - 엘리먼트가 하나 뿐이고, 이름이 `value`인 경우, 어노테이션을 적용할 때 엘리먼트 이름을 생략하고 값만 적어도 된다.


- 어노테이션에 값을 전달할 때 런타임 중에 알아내어야 하는 값은 들어갈 수 없다. 컴파일러 수준에서 해석되는 정적인 값만 들어갈 수 있다.


- 엘리먼트에는 예외를 선언할 수 없다. (ex: `int count() throws RuntimeException;`)

<br/>

```java
@interface AnnotationElement {
    int count() default 1;

    String testBy();

    String[] testTools() default {"aaa", "bbb", "ccc"};

    EnumType enumType();
}
```

<br>

## 표준 어노테이션

자바에서 기본적으로 제공해주는 어노테이션이다.

| 어노테이션 이름               | 설명                                 | 장점                                           |
|------------------------|------------------------------------|----------------------------------------------|
| `@Override`            | 컴파일러에게 오버라이딩하는 메서드라는 것을 알린다.       | 조상 메서드의 이름을 잘못 써서 오버라이딩을 하지 못하는 것을 방지할 수 있음. |
| `@Deprecated`          | 앞으로 사용하지 않을 것을 권장하는 대상에 붙인다.       | 더이상 사용되지 않는 것을 삭제하지 않고, 사용하지 말라고 권장할 수 있음    |
| `@SuppressWarnings`    | 컴파일러의 특정 경고메시지가 나타나지 않게 해준다.       | 컴파일러에 의해 생성되는 경고 메시지를 줄일 수 있음                |
| `@SafeVarargs`         | 메서드의 가변인자는 타입 안정성이 있다고 컴파일러에게 알린다. | 타입 안정성 경고 메시지를 줄일 수 있음                       |
| `@FunctionalInterface` | 함수형 인터페이스라는 것을 알린다.                | 함수형 인터페이스를 올바르게 선언했는지 확인함                    |
| `@Native`              | native 메서드에 의해 참조되는 상수 앞에 붙인다.     |                                              |

<br>

## 메타 어노테이션

어노테이션을 정의하기 위한 어노테이션의 어노테이션이다.

| Annotation    | 설명                                                       |
|---------------|----------------------------------------------------------|
| `@Target`     | 어노테이션 적용 가능 대상을 지정 (CLASS, METHOD, FIELD, CONSTRUCTOR 등) |
| `@Retention`  | 어노테이션이 유지되는 범위를 지정 (SOURCE, CLASS, RUNTIME)              |
| `@Documented` | 어노테이션 정보가 `javadoc`으로 작성된 문서에 포함된다.                      |
| `@Inherited`  | 상속받은 클래스에서도 어노테이션이 유지된다.                                 |
| `@Repetable`  | 하나의 대상에 같은 어노테이션을 여러번 붙일 수 있다                            |

<br/>

`예시: @Target`

```java

@Documented
@Retention(RetentionPolicy.RUNTIME) // 런타임까지 어노테이션 유지됨
@Target(ElementType.ANNOTATION_TYPE) // 적용 대상은 어노테이션
public @interface Target {
    ElementType[] value();
}

```

## Ref

- [[Java / Spring ] 어노테이션(@, annotation)의 정의와 종류](https://prinha.tistory.com/entry/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-annotation%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%A2%85%EB%A5%98)

- [[자바의 정석 - 기초편] ch12-23,24 애너테이션](https://www.youtube.com/watch?v=i4V8ZI9Undc)